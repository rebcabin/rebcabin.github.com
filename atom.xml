<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[The Light Cone]]></title>
  <link href="http://rebcabin.github.com/atom.xml" rel="self"/>
  <link href="http://rebcabin.github.com/"/>
  <updated>2013-02-05T09:01:02-08:00</updated>
  <id>http://rebcabin.github.com/</id>
  <author>
    <name><![CDATA[Brian Beckman (rebcabin = brianbec)]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Welford's Way to Kalman City]]></title>
    <link href="http://rebcabin.github.com/blog/2013/02/04/welfords-better-formula/"/>
    <updated>2013-02-04T06:48:00-08:00</updated>
    <id>http://rebcabin.github.com/blog/2013/02/04/welfords-better-formula</id>
    <content type="html"><![CDATA[<p>Should you square differences or should you difference squares?
Both methods harbor algebraically correct ways to compute <a href="http://localhost:4000/blog/2013/01/22/covariance-matrices/">incremental (co)variance</a>, 
but their numerical properties are different, as pointed out by
<a href="http://www.johndcook.com/blog/2008/09/26/comparing-three-methods-of-computing-standard-deviation/">John D. Cook here</a> and <a href="http://www.johndcook.com/blog/2008/09/28/theoretical-explanation-for-numerical-results/">here</a>.</p>

<p>When you square numbers, you do two risky things: you make big numbers
bigger and you make small numbers smaller.  Together, these effects
can be <a href="http://en.wikipedia.org/wiki/Loss_of_significance">catastrophic</a>.
Suppose, for instance, that you’re working with positive numbers that
look like $b+\epsilon$, where $b\geq 1$ and $0&lt;\epsilon&lt;1$. Squaring,
you get $b^2+2b\epsilon+\epsilon^2$. The big part, $b$, gets bigger:
$b^2$; and the small part, $\epsilon$, gets smaller:
$\epsilon^2$. Everyone knows you shouldn’t add big numbers to little
ones on computers.  The big ones crowd out space for the little ones.
You will eventually run out of <em>dynamic range</em> – the number of bits
in your machine numbers – and your squares will evaluate to
$b^2+2b\epsilon$ or even just to $b^2$.  This is the dreaded
<em>underflow</em>.</p>

<p>Remember those Mandelbrot-set-viewing programs?  If you kept zooming,
the picture would eventually get all soft and pillowy and you would
never get to see more detail.  That’s because you ran out of dynamic
range.  There wasn’t any room for all the heavenly beauty hiding in the $\epsilon^2$.
It takes special techniques to keep going; see <a href="http://www.hpdz.net/TechInfo.htm">high-precision deep zoom</a> and <a href="http://fractaljourney.blogspot.com/">fractaljourney</a>.</p>

<p>Now, when you try to subtract squares from one another, you get
another opportunity to mess up.  Everyone knows you shouldn’t subtract
nearly equal numbers on computers <em>and</em> expect the little bits to
contain good information (<a href="http://www.codeproject.com/Articles/25294/Avoiding-Overflow-Underflow-and-Loss-of-Precision">another John D. Cook article, here, elaborates</a>).
It’s another aspect of crowding out: the little bits you’re trying to
recover by subtracting were never there in the first place.</p>

<p>But why would it make a difference to square first, then subtract,
versus subtract first, then square?  If you square first and then
subtract, you’re subtracting extra-big numbers – bigger than you
need.  If you subtract first, you’re still exposed to crowding out,
but less so.  Squared numbers crowd out approximately twice the bits
of non-squared numbers.  You can avoid going to special techniques
longer if you subtract first and then square.</p>

<p>This is rather a deep and important observation, especially for sequential
estimation techniques like the <a href="http://en.wikipedia.org/wiki/Kalman_filter">Kalman filter</a>
and its many
variations. These techniques rely on accurate, iterative propagation
of covariance matrices. Losing even a little significance each round
can make a final result useless or worse, <em>i.e.</em>, not obviously wrong.</p>

<p>As a result, a whole technology of avoiding squares has arisen in the
filtering business.
<a href="http://ieeexplore.ieee.org/xpl/login.jsp?tp=&amp;arnumber=61004&amp;url=http%3A%2F%2Fieeexplore.ieee.org%2Fiel4%2F9%2F2222%2F00061004.pdf%3Farnumber%3D61004">Bierman’s work</a>
is in my own lineage due to my time at the Jet Propulsion Laboratory,
and searching for any of “Square-Root Information Filter,”
“Square-Root Sigma-Point Information Filter,” “Square-Root Unscented
Kalman Filter,” and so on will uncover a robust, contemporary literature on
continuing research and applications of sophisticated methods for
avoiding the squaring of machine numbers.</p>

<p>I can see a direct provenance of these techniques in Welford’s method,
the best method cited by John above.  Welford’s is a recurrence formula,
giving the sum of $N+1$ squared residuals in terms of the sum of $N$
squared residuals, where the residuals are differences of data from
their means.  Since the means can be calculated incrementally (never
requiring storage of all the data), Welford’s is also incremental,
requiring only the storage of prior results.  Welford’s formula is
also pretty to look at and easy to remember.</p>

<p>Let $S_N$ be the sum of squared residuals of the first $N$ data:</p>

<script type="math/tex; mode=display">
S_N := \sum_{i=1}^N{\left(x_i-\bar{x}_N\right)^2}
</script>

<!--
$$
\begin{align*}
r_{i,N} &:= (x_i-\bar{x}_N) \\ 
S_N     &:= \sum_{i=1}^N{r_{i,N}^2}
\end{align*}
$$
-->

<p>where $\bar{x}_N$ is the mean of the $N$ data $x_i,\,i\in [1..N]$:</p>

<script type="math/tex; mode=display">
\bar{x}_N:=\frac{1}{N}\sum_{i=1}^{N}{x_i} := \Sigma_N \left/ N \right.
</script>

<p>Then Welford’s update formula is</p>

<script type="math/tex; mode=display">
S_{N+1} = S_N + \left(x_{N+1}-\bar{x}_N\right)\left(x_{N+1}-\bar{x}_{N+1}\right)
</script>

<!--
Just multiply the new residual 
$x_{N+1}-\bar{x}_{N+1}$ 
times the
difference of the new datum and the old mean 
$x_{N+1}-\bar{x}_N$ 
and add it to the old sum of squared residuals $S_N$.
-->

<p>Generally, I prefer to remember the derivations of formulas along with
the formulas.  Doing so gives deeper, permanent understanding plus a
chance to reuse parts of the derivation in other formulas.  If I don’t
remember the derivation, it’s a little like knowing a tune without
knowing its chord progression and verse structure.  You might still be
able to play the tune, but not with as much conviction or creativity.</p>

<p>A brute-force expansion of the terms leads to a lot of messy
algebra that all cancels out, proving the formula correct, but not
yielding any insight into how the author may have seen the pretty and
memorable form.  <a href="http://planetmath.org/OnePassAlgorithmToComputeSampleVariance.html">An article at Planetmath.org</a> 
gave me the key to the puzzle: write $S_{N+1}$ as a sum of the same terms as in $S_N$, but with a correction $\gamma$:</p>

<script type="math/tex; mode=display">% &lt;![CDATA[

\begin{align*}

S_{N+1}
  &=\sum_{i=1}^{N+1}{\left(x_i - \bar{x}_{N+1}\right)^2} \\

  &=\sum_{i=1}^{N}{\left(x_i - \bar{x}_{N+1}\right)^2} + \left(x_{N+1}-\bar{x}_{N+1}\right)^2\\

  &=\sum_{i=1}^N{\left(x_i - \left(\bar{x}_{N} + \gamma\right)\right)^2} + \left(x_{N+1}-\bar{x}_{N+1}\right)^2

\end{align*}
 %]]&gt;</script>

<p>where</p>

<script type="math/tex; mode=display">
\gamma:=\bar{x}_{N+1}-\bar{x}_N
</script>

<p>Regroup the inner sum, then square:</p>

<script type="math/tex; mode=display">% &lt;![CDATA[

\begin{align*}

S_{N+1}
  &=\sum_{i=1}^N{\left(\left(x_i - \bar{x}_N\right) - \gamma\right)^2} + \left(x_{N+1}-\bar{x}_{N+1}\right)^2 \\

  &=\sum_{i=1}^N{\left(\left(x_i - \bar{x}_N\right)^2 - 2\gamma\left(x_i - \bar{x}_N\right)+\gamma^2\right)} + \left(x_{N+1}-\bar{x}_{N+1}\right)^2 \\

  &=\sum_{i=1}^N{\left(x_i - \bar{x}_N\right)^2} - 2\gamma\sum_{i=1}^N{\left(x_i - \bar{x}_N\right)} + \sum_{i=1}^N{\gamma^2} + \left(x_{N+1}-\bar{x}_{N+1}\right)^2 \\

  &=S_N+N\gamma^2+\left(x_{N+1}-\bar{x}_{N+1}\right)^2

\end{align*}
 %]]&gt;</script>

<p>because</p>

<script type="math/tex; mode=display">
\sum_{i=1}^{N}{\left(x_i - \bar{x}_N\right)} = 0
</script>

<p>That’s enough for an algorithm, but not quite enough to get to the
pretty, easy-to-remember formula (don’t get me started on the
practical utility of beauty in mathematics – for another time!).</p>

<p>We just need to show that</p>

<script type="math/tex; mode=display">
N\gamma^2 + \left(x_{N+1}-\bar{x}_{N+1}\right)^2 = 
\left(x_{N+1}-\bar{x}_N\right)\left(x_{N+1}-\bar{x}_{N+1}\right)
</script>

<p>But</p>

<script type="math/tex; mode=display">% &lt;![CDATA[

\begin{align*}

x_{N+1}
  &=(N+1)\,\bar{x}_{N+1}-N\bar{x}_{N} \\
  &=N\gamma +\bar{x}_{N+1}
\end{align*}
 %]]&gt;</script>

<p>so</p>

<script type="math/tex; mode=display">% &lt;![CDATA[

\begin{align*}

\left( x_{N+1}-\bar{x}_{N+1}\right)^{2}
  &=N^{2}\gamma^{2}
  
\end{align*}
 %]]&gt;</script>

<p>Now, the term we need to analyze is</p>

<script type="math/tex; mode=display">% &lt;![CDATA[

\begin{align*}

N\gamma^{2}+\left(x_{N+1}-\bar{x}_{N+1}\right)^{ 2 }
  &=(N+N^2)\,\gamma^2\\
  &=N\gamma\,\left(N+1\right)\,\gamma
  
\end{align*}
 %]]&gt;</script>

<p>We already found that</p>

<script type="math/tex; mode=display">
N\gamma
  = x_{N+1}-\bar{x}_{N+1}
</script>

<p>so we just look at</p>

<script type="math/tex; mode=display">% &lt;![CDATA[

\begin{align*}
\left(N+1\right)\,\gamma 
  &= \left(N+1\right)\left(\bar{x}_{N+1} - \bar{x}_N \right)\\
  &= \left(\left(N+1\right)\,\bar{x}_{N+1} - \left(N+1\right)\,\bar{x}_N \right)\\
  &= \left(\Sigma_{N+1} - \Sigma_N - \bar{x}_N \right)\\
  &= \left(x_{N+1} - \bar{x}_N \right)
\end{align*}
 %]]&gt;</script>

<p>Isn’t that fantastic?</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Incremental Covariance]]></title>
    <link href="http://rebcabin.github.com/blog/2013/01/22/covariance-matrices/"/>
    <updated>2013-01-22T10:02:00-08:00</updated>
    <id>http://rebcabin.github.com/blog/2013/01/22/covariance-matrices</id>
    <content type="html"><![CDATA[<p>Variance is a standard measure of spread of data.  It may be obvious
that it’s easy to keep a running average of a stream of data, but it
may not be so obvious that it’s also easy to keep a running
variance. The method generalizes to multivariate data streams, of
which the <em>covariance matrix</em> keeps track of variances and mutual
correlation coefficients. We will eventually travel through
eigenvectors and eigenvalues to orient and decompose covariance
matrices.</p>

<!--
Aside: my secondary agenda in this blog post was to really beat up on
my blogging tools: MathJax, Octopress, and Kramdown.  I could have
made this much shorter by leaving out numerical examples and
intermediate calculations.
-->

<h2 id="mean-and-variance">Mean and Variance</h2>

<p>Consider a column $N$-vector of numerical data:</p>

<script type="math/tex; mode=display">% &lt;![CDATA[
\mathbf{x}_N
=\begin{bmatrix}x_1 \\ x_2 \\ \cdots \\ x_N\end{bmatrix}
=\begin{bmatrix}x_1 & x_2 & \cdots & x_N\end{bmatrix}^T %]]&gt;</script>

<p>For instance, here are some random data: </p>

<script type="math/tex; mode=display">% &lt;![CDATA[
\mathbf{x}_5=\begin{bmatrix}48 & 29 & 46 & 57 & 34\end{bmatrix}^T %]]&gt;</script>

<p>The <em><strong>mean</strong></em> or average value of this vector is a number: the sum of
the vector’selements divided by the number $N$ of elements:</p>

<script type="math/tex; mode=display">\bar{x}_{N}=\frac{1}{N}\sum_{i=1}^N{x_i}={\Sigma_N\mathbf{x}_N}\left/{N}\right.</script>

<p>for instance, </p>

<script type="math/tex; mode=display">% &lt;![CDATA[
\bar{x}_5=\frac{\Sigma_5\begin{bmatrix}48 & 29 & 46 & 57 & 34\end{bmatrix}}{5}=\frac{214}{5} %]]&gt;</script>

<p>(we drop the Transpose superscript since the sum of a row vector is
the same as the sum of a column vector).</p>

<p>If you have a running stream of data, it’s easy to maintain its
average incrementally, meaning you don’t have to store the entire
vector to compute the mean-so-far. As $N$ increases to $N+1$, note
that</p>

<script type="math/tex; mode=display">\bar{x}_{N+1}={\frac{\Sigma_{N+1}\mathbf{x}_{N+1}}{N+1}}={\frac{\Sigma_{N}\mathbf{x}_N+x_{N+1}}{N+1}}=\frac{N\bar{x}_{N}+x_{N+1}}{N+1}</script>

<p>for instance, letting $x_6=66$ be a new datum arriving on the scene:</p>

<script type="math/tex; mode=display">% &lt;![CDATA[
\begin{align*}
\bar{x}_6&=\frac{\Sigma_6\begin{bmatrix}48 & 29 & 46 & 57 & 34 & 66\end{bmatrix}}{6}\\
&=\frac{\Sigma_5\begin{bmatrix}48 & 29 & 46 & 57 & 34\end{bmatrix}+66}{6}\\
&=\frac{5\times(214/5)+6}{6}\\
&=\frac{140}{3}
\end{align*} %]]&gt;</script>

<p>We see two algorithm choices for incrementally updating the average; informally:</p>

<ol>
  <li>keep a <strong>running sum</strong> of the data, and when you need the new average, just divide by the current number $N$ (second line in the example immediately above)</li>
  <li>keep a <strong>running average</strong>, and when you need the new average, multiply the old average by the old count $N$, add the new datum $x_{N+1}$, and divide the result by the new count of elements $N+1$ (third line in the example above)</li>
</ol>

<p>The first alternative may be cheaper since you don’t divide until you need the average. The second alternative has a certain mathematical elegance, but you must multiply and divide to get the new average. </p>

<p>With only a small variation in the algorithm, you can keep a <em><strong>sliding-window</strong></em> average over some fixed width $W$. Along with the running sum or average, keep a copy of the oldest datum used to calculate it. As the new datum arrives, subtract off the oldest one, add the newest one, and divide by the window width $W$. You will need special treatment until the window fills the first time, and possibly at the end if your stream of data is finite. </p>

<p>For instance, away from the ends, a width-$3$ moving average over the sample data can be kept as follows, imagining that we add incoming new values from the right of the window and subtract old values from the left of the window:</p>

<script type="math/tex; mode=display">% &lt;![CDATA[

\begin{align}
\begin{bmatrix}\text{avg}\begin{bmatrix}48 &29 &46\end{bmatrix}&57&34\end{bmatrix}
&=\begin{bmatrix}\begin{bmatrix}123\,/\,3\end{bmatrix}&57&34\end{bmatrix}\\ \\
\begin{bmatrix}48 &\text{avg}\begin{bmatrix}29 &46 &57\end{bmatrix}&34\end{bmatrix}
&=\begin{bmatrix}\begin{bmatrix}(123-48+57)\,/\,3\end{bmatrix}&34\end{bmatrix}\\
&=\begin{bmatrix}\begin{bmatrix}132\,/\,3\end{bmatrix}&34\end{bmatrix}\\ \\
\begin{bmatrix}48 & 29 & \text{avg}\begin{bmatrix}46 &57 &34\end{bmatrix}\end{bmatrix}
&=\begin{bmatrix}\begin{bmatrix}(132-29+34)\,/\,3\end{bmatrix}\end{bmatrix}\\
&=\begin{bmatrix}\begin{bmatrix}137\,/\,3\end{bmatrix}\end{bmatrix}
\end{align}
 %]]&gt;</script>

<p>Now, about variance. Given $N$ data, the sample variance is reckoned as
follows (though below we apply <a href="http://en.wikipedia.org/wiki/Bessel%27s_correction">Bessel’s Correction</a> to estimate population variance):</p>

<script type="math/tex; mode=display">s_N^2=\frac{1}{N}\sum_{i=1}^{N}{\left(\,x_i-\bar{x}_N\right)^2}</script>

<p>If we let</p>

<script type="math/tex; mode=display">\mathbf{1}_N=[\underbrace{1, 1, \dotsc, 1}_{N\text{ times}}]^T</script>

<p>be an $N$-vector of all $1$’s, and let</p>

<script type="math/tex; mode=display">\tilde{\mathbf{x}}_N=\mathbf{x}_N-\bar{x}_N\mathbf{1}_N</script>

<p>denote the $N$vector of <em><strong>residuals</strong></em> of the data from their mean, then the variance has the following beautiful expression as the scaled inner product:</p>

<script type="math/tex; mode=display">s_N^2=\tilde{\mathbf{x}}_N^T\tilde{\mathbf{x}}_N\left/{N}\right.</script>

<p>For instance, with our sample data</p>

<script type="math/tex; mode=display">
\tilde{\mathbf{x}}_5
=\begin{bmatrix}48 \\ 29 \\ 46 \\ 57 \\ 34\end{bmatrix}
- \left(\bar{x}_5=\frac{214}{5}\right)\times
\begin{bmatrix}1 \\ 1 \\ 1 \\ 1 \\ 1\end{bmatrix}
=\begin{bmatrix}26\,/\,5 \\ -69\,/\,5 \\ 16\,/\,5 \\ 71\,/\,5 \\ -44\,/\,5\end{bmatrix}
</script>

<script type="math/tex; mode=display">
s_5^2
=\frac{\tilde{\mathbf{x}}_5^T\tilde{\mathbf{x}}_5}{5}
=\frac{2534}{25}
</script>

<p>Expanding out the inner product, a form useful for incremental updating emerges:</p>

<script type="math/tex; mode=display">% &lt;![CDATA[
\begin{align*}
\tilde{\mathbf{x}}_N^T\tilde{\mathbf{x}}_N\left/{N}\right.&=\left(\mathbf{x}_N-\bar{x}_N\mathbf{1}_N\right)^T\left(\mathbf{x}_N-\bar{x}_N\mathbf{1}_N\right)\left/N\right. \\
&=\left(\mathbf{x}_N^T\mathbf{x}_N - N\bar{x}_N^2\right)\left/N\right. \\
s_N^2&=\mathbf{x}_N^T\mathbf{x}_N\left/N\right. - \bar{x}_N^2
\end{align*} %]]&gt;</script>

<p>For instance,</p>

<script type="math/tex; mode=display">
s_5^2
=\frac{\mathbf{x}_5^T\mathbf{x}_5=9666}{5}-\left(\frac{214}{5}\right)^2=\frac{2534}{25}
</script>

<p>When a new datum $x_{N+1}$ arrives,  update the variance in a way similar to the way we update the mean:</p>

<script type="math/tex; mode=display">% &lt;![CDATA[
\begin{align*}
s_{N+1}^2&=\frac{\tilde{\mathbf{x}}_{N+1}^T\tilde{\mathbf{x}}_{N+1}}{N+1}\\
&=\frac{\left(\mathbf{x}_{N+1}-\bar{x}_{N+1}\mathbf{1}_{N+1}\right)^T\left(\mathbf{x}_{N+1}-\bar{x}_{N+1}\mathbf{1}_{N+1}\right)}{N+1}\\
&=\frac{\mathbf{x}_{N+1}^T\mathbf{x}_{N+1}-\left(N+1\right)\:\bar{x}_{N+1}^2}{N+1}\\
&=\frac{\mathbf{x}_N^T\mathbf{x}_N+x_{N+1}^2-\left(N+1\right)\:\bar{x}_{N+1}^2}{N+1}\\
&=\frac{\mathbf{x}_N^T\mathbf{x}_N+x_{N+1}^2}{N+1}-\bar{x}_{N+1}^2\\
\end{align*}
 %]]&gt;</script>

<p>For instance</p>

<script type="math/tex; mode=display">
s_6^2=\frac{\mathbf{x}_N^T\mathbf{x}_N+x_{N+1}^2
=9666+66^2}{6}-\left(\frac{140}{3}\right)^2=\frac{1433}{9}
</script>

<p>This is really quite nice. Notice that </p>

<script type="math/tex; mode=display">
\mathbf{x}_N^T\mathbf{x}_N=\sum_{i=1}^{N}{x_i^2}
</script>

<p>for any $N$, so it’s the <em>running sum of squares</em>. We see that the variance is the running sum of squares divided by the current number $N$ of data minus the square of the current average.  This is our incremental formula for variance.  The only serious hazard we see here is that of <a href="http://en.wikipedia.org/wiki/Loss_of_significance"><em>catastrophic cancelation</em></a>: if the two quantities are of comparable magnitude, we can lose virtually all the precision.</p>

<h2 id="gaussian-distribution">Gaussian Distribution</h2>

<p>From the data, we might want a formula for the Gaussian distribution
that best fits the data.  The best-fit Gaussian should use the
<a href="http://mathworld.wolfram.com/SampleVariance.html">unbiased estimator for the population
variance</a>, related
to the sample variance we have been calculating, but with $N-1$
in the denominator instead of $N$ – Bessel’s correction. Letting</p>

<script type="math/tex; mode=display">
\sigma^2=\frac{N}{N-1}s_N^2,\quad\mu_N=\bar{x}_N
</script>

<p>The univariate Gaussian or Normal distribution depends on $\mu$ and
$\sigma$ and represents the probability that $x$ might lie in the
infinitesimal interval $x$ and $x+dx$:</p>

<script type="math/tex; mode=display">
\mathcal{N}(x;\mu,\sigma)=P(x) = \frac{1}{\sqrt{2\pi\sigma^2}}
\exp\left({-\frac{(x-\mu)^2}{2\sigma^2}}\right)
</script>

<p>We can plot the Gaussian that best fits our sample data along with a
histogram of our data and see a plausible match (we scaled up the
Gaussian by the area of the histogram, a somewhat arbitrary number
depending on the choice of histogram bin width):</p>

<p><img class="center" src="https://dl.dropbox.com/u/1997638/pdfx2.png" width="400" height="400" /></p>

<p>To quantitatively test the goodness-of-fit, apply something like the <a href="http://en.wikipedia.org/wiki/Chi-squared_test">Chi-Squared test</a> or the <a href="http://en.wikipedia.org/wiki/Kolmogorov%E2%80%93Smirnov_test">Kolmogorov-Smirnov test</a>. </p>

<h2 id="multivariate-distributions">Multivariate Distributions</h2>

<p>The particular form $\mathbf{x}_N^T\mathbf{x}$ goes over easily to an
elegant form for multivariate data, where we keep variances and
correlation coefficients in a matrix.</p>

<p>Consider a pair of column $N$-vectors of numerical data:</p>

<script type="math/tex; mode=display">% &lt;![CDATA[
\begin{align*}
\mathbf{x}&=\left[x_1, x_2, \dotsc, x_N\right]^T\\
\mathbf{y}&=\left[y_1, y_2, \dotsc, y_N\right]^T
\end{align*} %]]&gt;</script>

<p>Plotting $y$’s against $x$’s, we might see something like the following:</p>

<p><img class="center" src="https://dl.dropbox.com/u/1997638/xy.png" width="400" height="400" /></p>

<p>Now, calculate the mean of each vector:</p>

<script type="math/tex; mode=display">\bar{x}_N=\Sigma_N\mathbf{x}_N\left/N\right.,\;\; \bar{y}_N=\Sigma_N\mathbf{y}_N\left/N\right.</script>

<p>and the residuals</p>

<script type="math/tex; mode=display">
\tilde{\mathbf{x}}_N=\mathbf{x}_N-\bar{x}_N\mathbf{1}_N,\;\; \tilde{\mathbf{y}}_N=\mathbf{y}_N-\bar{y}_N\mathbf{1}_N
</script>

<p>Now imagine a column of rows in an outer product with a row of columns:</p>

<script type="math/tex; mode=display">% &lt;![CDATA[

\begin{bmatrix}
\tilde{\mathbf{x}}_N^T \\ \tilde{\mathbf{y}}_N^T
\end{bmatrix}
\begin{bmatrix}
\tilde{\mathbf{x}}_N    & \tilde{\mathbf{y}}_N
\end{bmatrix}
=
\begin{bmatrix}
\tilde{\mathbf{x}}_N^T\tilde{\mathbf{x}}_N & \tilde{\mathbf{x}}_N^T\tilde{\mathbf{y}}_N \\
\tilde{\mathbf{y}}_N^T\tilde{\mathbf{x}}_N & \tilde{\mathbf{y}}_N^T\tilde{\mathbf{y}}_N 
\end{bmatrix}
 %]]&gt;</script>

<p>Divide this by $N$ and call the result $S_N^2$:</p>

<script type="math/tex; mode=display">% &lt;![CDATA[
S_N^2=
\frac{1}{N}
\begin{bmatrix}
\tilde{\mathbf{x}}_N^T\tilde{\mathbf{x}}_N & \tilde{\mathbf{x}}_N^T\tilde{\mathbf{y}}_N \\
\tilde{\mathbf{y}}_N^T\tilde{\mathbf{x}}_N & \tilde{\mathbf{y}}_N^T\tilde{\mathbf{y}}_N 
\end{bmatrix}
 %]]&gt;</script>

<p>Each sub-product in the matrix can be computed incrementally as
described above, plus $\tilde{\mathbf{x}}_N^T\tilde{\mathbf{y}}_N =
\tilde{\mathbf{y}}_N^T\tilde{\mathbf{x}}_N$, so it is cheap to keep a running value for the
matrix.</p>

<p>Just as with the univariate Gaussian, we convert the sample covariance matrix
into an unbiased estimator of the population covariance matrix by multiplying
by $N$ and dividing by $N-1$. Let</p>

<script type="math/tex; mode=display">% &lt;![CDATA[
\Sigma_N^2=
\frac{1}{N-1}
\begin{bmatrix}
\tilde{\mathbf{x}}_N^T\tilde{\mathbf{x}}_N & \tilde{\mathbf{x}}_N^T\tilde{\mathbf{y}}_N \\
\tilde{\mathbf{y}}_N^T\tilde{\mathbf{x}}_N & \tilde{\mathbf{y}}_N^T\tilde{\mathbf{y}}_N 
\end{bmatrix}=
\frac{N S_N^2}{N-1}
 %]]&gt;</script>

<p>The bivariate Gaussian or normal distribution has such a beautiful form
that it can be remembered without looking it up:</p>

<script type="math/tex; mode=display">
\mathcal{N}(x, y\,;\mu, \sigma) = P(x,y) =\\
\frac{1}{2\pi\left|\Sigma^2\right|^{1/2}}
\exp
\left({-
\frac{1}{2}
\begin{bmatrix}
  x-\bar{x} \\ y-\bar{y}
\end{bmatrix}^T
\Sigma^{-2}
\begin{bmatrix}
  x-\bar{x} \\ y-\bar{y}
\end{bmatrix}
}\right)
</script>

<p>where $\left|\Sigma^2\right|^{1/2}$ is the square root of the determinant of 
$\Sigma^2$ and $\Sigma^{-2}$ is the inverse of $\Sigma^2$. The formula
generalizes to $D$ dimensions, in which case the coefficient $2\pi$ must
be written $(2\pi)^{D/2}$.</p>

<p>I created the example cloud of points above by sampling 500 points
from a bivariate Gaussian formula at a mean point of 
$\begin{bmatrix}\bar{x} &amp; \bar{y}\end{bmatrix} =
\begin{bmatrix}5 &amp; 5\end{bmatrix}
$ and the covariance matrix:</p>

<script type="math/tex; mode=display">% &lt;![CDATA[

\Sigma^2 = \frac{1}{16}
\begin{bmatrix}
16 & 7 \\ 7 & 8
\end{bmatrix}
=
\begin{bmatrix}
1 & 0.4375 \\ 0.4375 & 0.5
\end{bmatrix}
 %]]&gt;</script>

<p>If we calculate $\Sigma_N^2=\Sigma_{500}^2$, the unbiased population
covariance estimate, from the data, we get</p>

<script type="math/tex; mode=display">% &lt;![CDATA[

\begin{bmatrix}
0.9455 & 0.4276 \\ 0.4276 & 0.4992
\end{bmatrix}
 %]]&gt;</script>

<p>plasibly close to the original (though a formal test, as mentioned, 
would be required to say quantitatively how much).</p>

<p>Later, we have to figure out exactly <em>how</em> to sample a multivariate
Gaussian like this (hints: do the sampling in a new coordinate system
in which the $x$ and $y$ variables are uncorrelated. That is a
coordinate system in which the principal axes of the cloud are aligned
with the $x$ and $y$ axes. That entails a Principal-Component Analysis
(PCA) of the covariance matrix or its inverse and their square roots,
which can be cheaply done with the Singular-Value Decomposition (SVD).</p>

<!--
This is symmetric because $\tilde{\mathbf{x}}_N^T \tilde{\mathbf{y}}_N=\tilde{\mathbf{y}}_N^T \tilde{\mathbf{x}}_N$. 

$$
\begin{align*}
  & \phi(x,y) = \phi \left(\sum_{i=1}^n x_ie_i, \sum_{j=1}^n y_je_j \right)
  = \sum_{i=1}^n \sum_{j=1}^n x_i y_j \phi(e_i, e_j) = \\
  & (x_1, \ldots, x_n) \left( \begin{array}{ccc}
      \phi(e_1, e_1) & \cdots & \phi(e_1, e_n) \\
      \vdots & \ddots & \vdots \\
      \phi(e_n, e_1) & \cdots & \phi(e_n, e_n)
    \end{array} \right)
  \left( \begin{array}{c}
      y_1 \\
      \vdots \\
      y_n
    \end{array} \right)
\end{align*}
$$
-->
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Asynchronous Lazy Lists]]></title>
    <link href="http://rebcabin.github.com/blog/2013/01/19/asynchronous-lazy-lists/"/>
    <updated>2013-01-19T22:03:00-08:00</updated>
    <id>http://rebcabin.github.com/blog/2013/01/19/asynchronous-lazy-lists</id>
    <content type="html"><![CDATA[<h2 id="synchronous-lazy-lists">SYNCHRONOUS LAZY LISTS</h2>

<p>Lazy lists make it easy to write infinite data sets without doing infinite computations. For instance, the following static method in C# will generate a lazy list that serves up all the integers (actually, all the 32-bit integers in an infinite cycle, but we quibble):</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>A lazy list for an infinite stream of ints</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class="csharp"><span class="line"><span class="k">public</span> <span class="k">static</span> <span class="n">LazyList</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;</span> <span class="n">integers</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="k">return</span> <span class="k">new</span> <span class="n">LazyList</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;</span> <span class="p">{</span><span class="k">value</span> <span class="p">=</span> <span class="n">n</span><span class="p">,</span> <span class="n">rest</span> <span class="p">=</span> <span class="p">()</span> <span class="p">=&gt;</span> <span class="n">integers</span><span class="p">(</span><span class="n">n</span> <span class="p">+</span> <span class="m">1</span><span class="p">)};</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>Notice that an instance of this <code>LazyList</code> type has two properties (or fields, if you prefer): a <code>value</code> and a <code>rest</code>, which is a function, (lambda expression) that, when invoked, will produce the rest of the infinite stream. That’s the essence of the technique: keep the infinite stuff in a function, recursively, and pick out values only when you need them. </p>

<p>Next is my implementation of the <code>LazyList</code> class.  Of course, I could use <a href="http://msdn.microsoft.com/en-us/library/dd642331.aspx">C#’s built-in <code>Lazy</code> type</a>, but I am, on purpose, doing the details myself for deeper understanding and exploration. We’re going to morph these into task-based LazyLists that produce the downstream values asynchronously:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>Implementation of the LazyList class</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
</pre></td><td class="code"><pre><code class="csharp"><span class="line"><span class="k">public</span> <span class="k">class</span> <span class="nc">LazyList</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="k">public</span> <span class="n">T</span> <span class="k">value</span><span class="p">;</span>
</span><span class="line">    <span class="k">public</span> <span class="n">Func</span><span class="p">&lt;</span><span class="n">LazyList</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;&gt;</span> <span class="n">rest</span><span class="p">;</span>
</span><span class="line">
</span><span class="line">    <span class="k">public</span> <span class="n">T</span> <span class="nf">nth</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
</span><span class="line">    <span class="p">{</span>
</span><span class="line">        <span class="k">return</span>
</span><span class="line">            <span class="p">(</span><span class="n">n</span> <span class="p">&lt;=</span> <span class="m">1</span><span class="p">)</span> <span class="p">?</span>
</span><span class="line">            <span class="k">value</span> <span class="p">:</span>
</span><span class="line">            <span class="n">rest</span><span class="p">().</span><span class="n">nth</span><span class="p">(</span><span class="n">n</span> <span class="p">-</span> <span class="m">1</span><span class="p">);</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>In addition to the properties already mentioned, I’ve included an <code>nth</code> method that walks up the lazy list in O(n) time to get the <code>n</code>-th item (without the <a href="http://stackoverflow.com/questions/7102520/does-c-sharp-do-tail-recursion">tail-recursion optimization</a>, this code will also consume O(n) space on the stack).  This is not designed to fetch the <code>n</code>-th item directly, as is possible with some <a href="http://en.wikipedia.org/wiki/Spigot_algorithm">spigot algorithms</a>, and it might be very interesting to explore spigots using lazy techniques in C#, but perhaps another time.</p>

<p>Next is a little more meat on the bones: the obligatory factorial:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>A LazyList that produces factorials</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
</pre></td><td class="code"><pre><code class="csharp"><span class="line"><span class="k">public</span> <span class="k">static</span> <span class="n">LazyList</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;</span> <span class="n">factorials</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="k">return</span> <span class="k">new</span> <span class="n">LazyList</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;</span>
</span><span class="line">    <span class="p">{</span>
</span><span class="line">        <span class="k">value</span> <span class="p">=</span> <span class="p">(</span><span class="n">n</span> <span class="p">&lt;=</span> <span class="m">1</span><span class="p">)</span> <span class="p">?</span> <span class="m">1</span> <span class="p">:</span> <span class="n">n</span> <span class="p">*</span> <span class="n">factorials</span><span class="p">(</span><span class="n">n</span> <span class="p">-</span> <span class="m">1</span><span class="p">).</span><span class="k">value</span><span class="p">,</span>
</span><span class="line">        <span class="n">rest</span> <span class="p">=</span> <span class="p">()</span> <span class="p">=&gt;</span> <span class="n">factorials</span><span class="p">(</span><span class="n">n</span> <span class="p">+</span> <span class="m">1</span><span class="p">)</span>
</span><span class="line">    <span class="p">};</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>This one uses recursion in the production of <code>value</code>.  There are two uses of recursion: <code>value</code> recursively uses prior values, <code>rest</code> recursively produces future values. This is pretty neat. Both uses of recursion are completely synchronous and all this code runs on one thread.</p>

<p>We could go on to fibonaccis and more exotic streams; we could anonymize these for remoting, memoize them for efficiency, as explained <a href="http://rebcabin.github.com/blog/2012/12/08/anonymous-memoizing-lazy-lists/">an earlier post on this blog</a>; but that’s not where we’re going today.</p>

<p>One last thing before going <code>async</code>, and thats for a bit of code that exercises the above, using <a href="http://www.linqpad.net">LinqPad</a>:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>Exercising the LazyLists</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
</pre></td><td class="code"><pre><code class="csharp"><span class="line"><span class="k">void</span> <span class="nf">Main</span><span class="p">()</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="kt">var</span> <span class="n">k1</span> <span class="p">=</span> <span class="n">integers</span><span class="p">(</span><span class="m">1</span><span class="p">);</span>
</span><span class="line">    <span class="c1">// Expect 5</span>
</span><span class="line">    <span class="n">k1</span><span class="p">.</span><span class="n">nth</span><span class="p">(</span><span class="m">5</span><span class="p">).</span><span class="n">Dump</span><span class="p">();</span>
</span><span class="line">
</span><span class="line">    <span class="kt">var</span> <span class="n">k2</span> <span class="p">=</span> <span class="n">factorials</span><span class="p">(</span><span class="m">1</span><span class="p">);</span>
</span><span class="line">    <span class="c1">// Expect 120</span>
</span><span class="line">    <span class="n">k2</span><span class="p">.</span><span class="n">nth</span><span class="p">(</span><span class="m">5</span><span class="p">).</span><span class="n">Dump</span><span class="p">();</span>
</span><span class="line">
</span><span class="line">    <span class="c1">// A hint for what&#39;s coming up next</span>
</span><span class="line">    <span class="n">AsyncMain</span><span class="p">();</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>Much more with synchronous lazy streams can be found in this wonderful paper: 
<a href="http://www.cs.dartmouth.edu/~doug/music.ps.gz">Music of the Streams by Doug McIlroy</a>. But on to asynchrony for us.</p>

<h2 id="asynchronous-lazy-lists-with-task">ASYNCHRONOUS LAZY LISTS WITH TASK</h2>

<p>Let’s start with ‘what-we-want’ in AsyncMain:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>AsyncMain</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
</pre></td><td class="code"><pre><code class="csharp"><span class="line"><span class="k">public</span> <span class="k">static</span> <span class="k">async</span> <span class="k">void</span> <span class="nf">AsyncMain</span><span class="p">()</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="n">DumpThreadId</span><span class="p">(</span><span class="s">&quot;Async main, k3: &quot;</span><span class="p">);</span>
</span><span class="line">    <span class="kt">var</span> <span class="n">k3</span> <span class="p">=</span> <span class="n">asyncIntegers</span><span class="p">(</span><span class="m">1</span><span class="p">);</span>
</span><span class="line">    <span class="p">(</span><span class="k">await</span> <span class="n">k3</span><span class="p">.</span><span class="n">nth</span><span class="p">(</span><span class="m">5</span><span class="p">)).</span><span class="n">Dump</span><span class="p">();</span>
</span><span class="line">
</span><span class="line">    <span class="n">DumpThreadId</span><span class="p">(</span><span class="s">&quot;Async main, k4: &quot;</span><span class="p">);</span>
</span><span class="line">    <span class="kt">var</span> <span class="n">k4</span> <span class="p">=</span> <span class="n">asyncFactorials</span><span class="p">(</span><span class="m">1</span><span class="p">);</span>
</span><span class="line">    <span class="p">(</span><span class="k">await</span> <span class="n">k4</span><span class="p">.</span><span class="n">nth</span><span class="p">(</span><span class="m">5</span><span class="p">)).</span><span class="n">Dump</span><span class="p">();</span>
</span><span class="line">
</span><span class="line">    <span class="kt">var</span> <span class="n">z0</span> <span class="p">=</span> <span class="p">(</span><span class="k">await</span> <span class="n">Task</span><span class="p">.</span><span class="n">Run</span><span class="p">(()</span> <span class="p">=&gt;</span>
</span><span class="line">    <span class="p">{</span>   <span class="n">DumpThreadId</span><span class="p">(</span><span class="s">&quot;Anonymous task: &quot;</span><span class="p">);</span>
</span><span class="line">        <span class="n">Thread</span><span class="p">.</span><span class="n">Sleep</span><span class="p">(</span><span class="n">ran</span><span class="p">.</span><span class="n">Next</span><span class="p">(</span><span class="m">200</span><span class="p">));</span>
</span><span class="line">        <span class="k">return</span> <span class="m">42</span><span class="p">;</span>
</span><span class="line">    <span class="p">}));</span>
</span><span class="line">
</span><span class="line">    <span class="n">DumpThreadId</span><span class="p">(</span><span class="s">&quot;Async main, z0: &quot;</span><span class="p">);</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>We made a new main because <a href="http://msdn.microsoft.com/en-us/library/vstudio/hh156513.aspx">we needed it to be <code>async</code></a> and we can’t mark the regular <code>Main</code> as <code>async</code>.  What we want, here, is to <code>await</code> the computation of <code>asyncIntegers</code> and <code>asyncFactorials</code> in the body of <code>AsyncMain</code>.  This can cause various threads to jump around in our code, so we’re careful to print thread id’s after every <code>await</code> and in the body of every lambda expression that runs asynchronously in 
a task, via the following static method:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>How to dump a thread id</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="csharp"><span class="line"><span class="k">public</span> <span class="k">static</span> <span class="k">void</span> <span class="nf">DumpThreadId</span><span class="p">(</span><span class="kt">string</span> <span class="n">msg</span> <span class="p">=</span> <span class="s">&quot;&quot;</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>   <span class="n">System</span><span class="p">.</span><span class="n">Threading</span><span class="p">.</span><span class="n">Thread</span><span class="p">.</span><span class="n">CurrentThread</span><span class="p">.</span><span class="n">ManagedThreadId</span><span class="p">.</span><span class="n">Dump</span><span class="p">(</span><span class="n">msg</span> <span class="p">+</span> <span class="s">&quot;Thread Id&quot;</span><span class="p">);</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>We’ll also insert a number of artificial random delays to try to entice the thread scheduler to send different threads through our code.  None of these <code>Sleeps</code> are part of the algorithm at all; they’re here to induce interesting behavior.</p>

<p>Now look at the implementation of <code>asyncIntegers</code>:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>asyncIntegers</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
</pre></td><td class="code"><pre><code class="csharp"><span class="line"><span class="k">public</span> <span class="k">static</span> <span class="n">AsyncList</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;</span> <span class="n">asyncIntegers</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>   <span class="k">return</span> <span class="k">new</span> <span class="n">AsyncList</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;</span>
</span><span class="line">    <span class="p">{</span>   <span class="k">value</span> <span class="p">=</span> <span class="n">n</span><span class="p">,</span>
</span><span class="line">        <span class="n">rest</span> <span class="p">=</span> <span class="p">()</span> <span class="p">=&gt;</span>
</span><span class="line">        <span class="p">{</span>   <span class="n">DumpThreadId</span><span class="p">(</span><span class="s">&quot;AsyncIntegers, rest: &quot;</span><span class="p">);</span>
</span><span class="line">            <span class="n">Thread</span><span class="p">.</span><span class="n">Sleep</span><span class="p">(</span><span class="n">ran</span><span class="p">.</span><span class="n">Next</span><span class="p">(</span><span class="m">200</span><span class="p">));</span>
</span><span class="line">            <span class="k">return</span> <span class="nf">asyncIntegers</span><span class="p">(</span><span class="n">n</span> <span class="p">+</span> <span class="m">1</span><span class="p">);</span>
</span><span class="line">        <span class="p">}</span>
</span><span class="line">    <span class="p">};</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>Looks just like the implementation of lazy integers.  The variable <code>k3 = asyncIntegers(5)</code> in <code>AsyncMain</code> must be of type <code>AsyncList</code>.   The deeper differences are in <code>nth</code>, the method we use to walk the lazy list:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>AsyncList</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
</pre></td><td class="code"><pre><code class="csharp"><span class="line"><span class="k">public</span> <span class="k">class</span> <span class="nc">AsyncList</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span>
</span><span class="line"><span class="p">{</span>   <span class="k">public</span> <span class="n">T</span> <span class="k">value</span><span class="p">;</span>
</span><span class="line">    <span class="k">public</span> <span class="n">Func</span><span class="p">&lt;</span><span class="n">AsyncList</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;&gt;</span> <span class="n">rest</span><span class="p">;</span>
</span><span class="line">
</span><span class="line">    <span class="k">public</span> <span class="k">async</span> <span class="n">Task</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">nth</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
</span><span class="line">    <span class="p">{</span>   <span class="k">return</span>
</span><span class="line">            <span class="p">(</span><span class="n">n</span> <span class="p">&lt;=</span> <span class="m">1</span><span class="p">)</span> <span class="p">?</span>
</span><span class="line">            <span class="k">await</span> <span class="p">(</span><span class="n">Task</span><span class="p">.</span><span class="n">Run</span><span class="p">(()</span> <span class="p">=&gt;</span>
</span><span class="line">            <span class="p">{</span>   <span class="n">DumpThreadId</span><span class="p">(</span><span class="s">&quot;AsyncList, nth: &quot;</span><span class="p">);</span>
</span><span class="line">                <span class="k">return</span> <span class="k">value</span><span class="p">;</span>
</span><span class="line">            <span class="p">}))</span> <span class="p">:</span>
</span><span class="line">            <span class="k">await</span> <span class="n">Task</span><span class="p">.</span><span class="n">Run</span><span class="p">(()</span> <span class="p">=&gt;</span>
</span><span class="line">            <span class="p">{</span>   <span class="n">Thread</span><span class="p">.</span><span class="n">Sleep</span><span class="p">(</span><span class="n">ran</span><span class="p">.</span><span class="n">Next</span><span class="p">(</span><span class="m">200</span><span class="p">));</span>
</span><span class="line">                <span class="k">return</span> <span class="nf">rest</span><span class="p">().</span><span class="n">nth</span><span class="p">(</span><span class="n">n</span> <span class="p">-</span> <span class="m">1</span><span class="p">);</span>
</span><span class="line">            <span class="p">});</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>We use only one facet of <a href="http://msdn.microsoft.com/en-us/library/vstudio/dd321424.aspx">the multifaceted <code>Task</code> class</a>. The rule we use is that <code>Task.Run</code>, when given a <code>Func&lt;T&gt;</code>, produces a <code>Task&lt;T&gt;</code>. Awaiting a <code>Task&lt;T&gt;</code> prduces a <code>T</code>.  So, except for the routing through <code>Task</code>, it looks like invoking a <code>Func&lt;T&gt;</code> to produce a <code>T</code>. This seems like a minimal intrusion of task-ness on our original lazy-list design.</p>

<p>Look at the first branch of <code>nth</code>, when <code>n &lt;= 1</code>. We <code>await</code> a <code>Task.Run</code> of a <code>Func&lt;T&gt;</code> that produces <code>value</code>, so the result of the <code>await</code> is of type <code>T</code>, the type of <code>value</code>.  This <code>T</code> gets returned through an <code>async</code> method, namely <code>nth</code>, so it gets converted back into a <code>Task&lt;T&gt;</code> on the way out.  In the body of <code>AsyncMain</code>, where we are calling <code>nth</code>, we <code>await</code> this <code>Task&lt;T&gt;</code>, getting back a <code>T</code> in the end. </p>

<p><code>T</code>’s become <code>Task&lt;T&gt;</code> when run under <code>Task.Run</code> or when returned from any <code>async</code> method that would otherwise produce a <code>T</code>.  <code>Task&lt;T&gt;</code>’s become <code>T</code>’s when <code>awaited</code> (there’s a monad in here somewhere, but that’s for another time, too).</p>

<p>On the other branch of <code>nth</code>, The new <code>rest</code> will walk up the lazy list just as before, only awaiting the value of <code>rest().nth(n-1)</code> to get a <code>T</code>; and returning it through the <code>async</code> to get a <code>Task&lt;T&gt;</code> on the way out (EDIT: thanks to Brian Grunkmeyer for a bug fix here).</p>

<p>On both branches, <code>nth</code> is of type <code>Task&lt;T&gt;</code>, just what we need to <code>await</code> on in the caller to get <code>T</code>’s. </p>

<p>Here is the more meaty async factorial, which doesn’t differ in any interesting way from the lazy-list factorial:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>asyncFactorial</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
</pre></td><td class="code"><pre><code class="csharp"><span class="line"><span class="k">public</span> <span class="k">static</span> <span class="n">AsyncList</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;</span> <span class="n">asyncFactorials</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>   <span class="k">return</span> <span class="k">new</span> <span class="n">AsyncList</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;</span>
</span><span class="line">    <span class="p">{</span>   <span class="k">value</span> <span class="p">=</span> <span class="p">(</span><span class="n">n</span> <span class="p">&lt;=</span> <span class="m">1</span><span class="p">)</span> <span class="p">?</span> <span class="m">1</span> <span class="p">:</span> <span class="n">n</span> <span class="p">*</span> <span class="n">asyncFactorials</span><span class="p">(</span><span class="n">n</span> <span class="p">-</span> <span class="m">1</span><span class="p">).</span><span class="k">value</span><span class="p">,</span>
</span><span class="line">        <span class="n">rest</span> <span class="p">=</span> <span class="p">()</span> <span class="p">=&gt;</span>
</span><span class="line">        <span class="p">{</span>   <span class="n">DumpThreadId</span><span class="p">(</span><span class="s">&quot;AsyncFactorials, rest: &quot;</span><span class="p">);</span>
</span><span class="line">            <span class="n">Thread</span><span class="p">.</span><span class="n">Sleep</span><span class="p">(</span><span class="n">ran</span><span class="p">.</span><span class="n">Next</span><span class="p">(</span><span class="m">200</span><span class="p">));</span>
</span><span class="line">            <span class="k">return</span> <span class="nf">asyncFactorials</span><span class="p">(</span><span class="n">n</span> <span class="p">+</span> <span class="m">1</span><span class="p">);</span>
</span><span class="line">        <span class="p">}</span>
</span><span class="line">    <span class="p">};</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>It may take a few tries to get a lot of thread variety: the thread-pool scheduler seems to have hints from your code and tries to reuse the same thread whenever it can.  But eventually, you can get a trace like the following that shows various thread moving around these tasks. </p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>asyncFactorial</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
<span class="line-number">30</span>
<span class="line-number">31</span>
<span class="line-number">32</span>
<span class="line-number">33</span>
<span class="line-number">34</span>
<span class="line-number">35</span>
<span class="line-number">36</span>
<span class="line-number">37</span>
<span class="line-number">38</span>
<span class="line-number">39</span>
<span class="line-number">40</span>
<span class="line-number">41</span>
<span class="line-number">42</span>
<span class="line-number">43</span>
<span class="line-number">44</span>
<span class="line-number">45</span>
</pre></td><td class="code"><pre><code class="csharp"><span class="line"><span class="m">5</span>
</span><span class="line"><span class="m">120</span>
</span><span class="line"><span class="n">Async</span> <span class="n">main</span><span class="p">,</span> <span class="n">k3</span><span class="p">:</span> <span class="n">Thread</span> <span class="n">Id</span>
</span><span class="line"><span class="m">16</span>
</span><span class="line">
</span><span class="line"><span class="n">AsyncIntegers</span><span class="p">,</span> <span class="n">rest</span><span class="p">:</span> <span class="n">Thread</span> <span class="n">Id</span>
</span><span class="line"><span class="m">22</span>
</span><span class="line">
</span><span class="line"><span class="n">AsyncIntegers</span><span class="p">,</span> <span class="n">rest</span><span class="p">:</span> <span class="n">Thread</span> <span class="n">Id</span>
</span><span class="line"><span class="m">37</span>
</span><span class="line">
</span><span class="line"><span class="n">AsyncIntegers</span><span class="p">,</span> <span class="n">rest</span><span class="p">:</span> <span class="n">Thread</span> <span class="n">Id</span>
</span><span class="line"><span class="m">37</span>
</span><span class="line">
</span><span class="line"><span class="n">AsyncIntegers</span><span class="p">,</span> <span class="n">rest</span><span class="p">:</span> <span class="n">Thread</span> <span class="n">Id</span>
</span><span class="line"><span class="m">37</span>
</span><span class="line">
</span><span class="line"><span class="n">AsyncList</span><span class="p">,</span> <span class="n">nth</span><span class="p">:</span> <span class="n">Thread</span> <span class="n">Id</span>
</span><span class="line"><span class="m">37</span>
</span><span class="line">
</span><span class="line"><span class="m">5</span>
</span><span class="line"><span class="n">Async</span> <span class="n">main</span><span class="p">,</span> <span class="n">k4</span><span class="p">:</span> <span class="n">Thread</span> <span class="n">Id</span>
</span><span class="line"><span class="m">37</span>
</span><span class="line">
</span><span class="line"><span class="n">AsyncFactorials</span><span class="p">,</span> <span class="n">rest</span><span class="p">:</span> <span class="n">Thread</span> <span class="n">Id</span>
</span><span class="line"><span class="m">37</span>
</span><span class="line">
</span><span class="line"><span class="n">AsyncFactorials</span><span class="p">,</span> <span class="n">rest</span><span class="p">:</span> <span class="n">Thread</span> <span class="n">Id</span>
</span><span class="line"><span class="m">37</span>
</span><span class="line">
</span><span class="line"><span class="n">AsyncFactorials</span><span class="p">,</span> <span class="n">rest</span><span class="p">:</span> <span class="n">Thread</span> <span class="n">Id</span>
</span><span class="line"><span class="m">37</span>
</span><span class="line">
</span><span class="line"><span class="n">AsyncFactorials</span><span class="p">,</span> <span class="n">rest</span><span class="p">:</span> <span class="n">Thread</span> <span class="n">Id</span>
</span><span class="line"><span class="m">37</span>
</span><span class="line">
</span><span class="line"><span class="n">AsyncList</span><span class="p">,</span> <span class="n">nth</span><span class="p">:</span> <span class="n">Thread</span> <span class="n">Id</span>
</span><span class="line"><span class="m">26</span>
</span><span class="line">
</span><span class="line"><span class="m">120</span>
</span><span class="line"><span class="n">Anonymous</span> <span class="n">task</span><span class="p">:</span> <span class="n">Thread</span> <span class="n">Id</span>
</span><span class="line"><span class="m">37</span>
</span><span class="line">
</span><span class="line"><span class="n">Async</span> <span class="n">main</span><span class="p">,</span> <span class="n">z0</span><span class="p">:</span> <span class="n">Thread</span> <span class="n">Id</span>
</span><span class="line"><span class="m">37</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>A gist for this LINQPad script can be found here: <a href="https://gist.github.com/4580491">https://gist.github.com/4580491</a>.  </p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Fast Arbitrary Non-Uniform Randoms]]></title>
    <link href="http://rebcabin.github.com/blog/2012/12/13/fast-arbitrary-non-uniform-randoms/"/>
    <updated>2012-12-13T08:28:00-08:00</updated>
    <id>http://rebcabin.github.com/blog/2012/12/13/fast-arbitrary-non-uniform-randoms</id>
    <content type="html"><![CDATA[<p>You give me an array of integers representing the distribution of outcomes of some discrete random process (translation: you give me the specification of a loaded die: “I want 1 to come up 7/39 of the time; 2 to come up 5/39 of the time; I’d better NEVER see a 3 ‘cause I’m betting the farm on that; 4 to come up 11/39 of the time; 5 to come up 3/39 of the time; and 6 to come up 13/39 of the time.”).  You also give me a uniform pseudo-random number generator (PRNG) like Mathematica’s <a href="http://reference.wolfram.com/mathematica/ref/RandomInteger.html?q=RandomInteger&amp;lang=en">Random Integer</a>.  I give you back a new PRNG that honors the distribution you gave me, in the sense that, statistically, it generates outcomes with the same distribution as you gave me.</p>

<p>The problem is a practical, real-world problem.  Any time you need to generate random numbers according to some arbitrary, given distribution such as in simulation, traversing a Bayesian network, a decision tree, a packet retry backoff schedule, you name it, the problem comes up.  In my work, it comes up every time I need to generate random expressions for testing parsers or for Monte-Carlo search for formulas.  Most of the time, you want to generate expressions non-uniformly.  For instance, you’d like to generate addition expressions more frequently than division expressions or function calls more frequently than function definitions.  </p>

<p>There are a lot of solutions to this problem.  Probability mavens will immediately see that the problem boils down to <a href="http://en.wikipedia.org/wiki/Inverse_transform_sampling">inverting the CDF</a>.  We can do this by:</p>

<ul>
  <li>linear search – O(N) space, O(N) time, where N is the number of different outcomes – the number of elements in the original array – the number of sides on the loaded die – 6 in our example</li>
  <li>binary search – O(N) space, O(log(N)) time – this works because the CDF is monotonically increasing</li>
  <li>by constructing an explicit inverse in an array – O(S) space, O(1) time, where S is the sum of the numbers in the array – the total number of trials imputed in the original distribution – 39 in our example </li>
  <li>by my favorite method: <a href="http://code.activestate.com/recipes/576564-walkers-alias-method-for-random-objects-with-diffe/">Walker’s method of aliases</a> – O(N) space and O(1) time.</li>
</ul>

<p>At first glance, this seems ridiculous, but there is a way.  In a nutshell: paint a dartboard with colors in the given proportions, throw darts, lookup the colors (thanks to Terence Spies for this beautiful idea).</p>

<p>Less metaphorically: imagine that the counts are colored balls distributed in bins:</p>

<ol>
  <li>7 balls of color number 1 in bin number 1</li>
  <li>5 balls of color number 2 in bin number 2</li>
  <li>0 balls of color number 3 in bin number 3</li>
  <li>11 balls of color number 4 in bin number 4</li>
  <li>3 balls of color number 5 in bin number 5</li>
  <li>13 balls of color number six in bin number 6</li>
</ol>

<p>Scale up the given counts of balls until the total is divisible by N – multiply every count by D/S where D=lcm(N,S)=lcm(6,39)=78: D/S=2</p>

<p>Now we have</p>

<ol>
  <li>14 balls of color number 1 in bin number 1</li>
  <li>10 balls of color number 2 in bin number 2</li>
  <li>0 balls of color number 3 in bin number 3</li>
  <li>22 balls of color number 4 in bin number 4</li>
  <li>6 balls of color number 5 in bin number 5</li>
  <li>26 balls of color number six in bin number 6</li>
</ol>

<p>Redistribute the counts amongst the bins so that every bin contains the same number of counts, namely D/N=13, and that the following conditions obtain:</p>

<ul>
  <li>every new bin contains at most 2 colors</li>
  <li>you never take ALL the balls out of any bin – every bin contains at least one ball of its original color if it had any</li>
</ul>

<p>There is a very elegant algorithm for this redistribution process.  It’s a one-liner whose statement is a proof of its correctness.  Think a minute, if you like, to see if you can come up with it, but here it is:</p>

<p>Fill up the shortest bin from the tallest bin; remove the new filled bin from the game and continue.</p>

<p>Do this procedure on a piece of paper:</p>

<ol>
  <li>Take 13 balls from bin 6 leaving 13 balls; fill up and remove bin 3</li>
  <li>Take 7 balls from bin 4 leaving 15 balls; fill up and remove bin 5</li>
  <li>Take 3 balls from bin 4 leaving 12 balls; fill up and remove bin 2</li>
  <li>Take 1 ball from bin 1 leaving 13 balls; fill up and remove bin 4</li>
  <li>Bins 1 and 6 are left with 13 balls each; we’re done (mechanically, you can imagine taking 0 balls from bin 6, filling up bin 1; removing bin 1, leaving just one bin – bin 6).</li>
</ol>

<p>you should end up with </p>

<ol>
  <li>13 balls of color 1 in bin 1 and no balls of any foreign color</li>
  <li>10 balls of color 2 and 3 balls of color 4 in bin 2</li>
  <li>0 balls of color 3 and 13 balls of color 6 in bin 3</li>
  <li>12 balls of color 4 and 1 balls of color 1 in bin 4</li>
  <li>6 balls of color 5 and 7 balls of color 4 in bin 5</li>
  <li>13 balls of color 6 in bin 6 and no balls of any foreign color</li>
</ol>

<p>Now, to generate new randoms, roll once to choose a bin <code>RandomInteger[{1,N}]</code>, and roll again to choose a height <code>RandomInteger[{1,D/N}]</code>.  If the randomly chosen height is less than or equal to the number of balls of the home color, return the number of the home color; otherwise, return the number of the foreign color. </p>

<p>Nifty, eh?  Here is a Mathematica notebook with an implementation tuned for clarity: <a href="https://dl.dropbox.com/u/1997638/FastNonUniformPseudoRandoms.cdf">https://dl.dropbox.com/u/1997638/FastNonUniformPseudoRandoms.cdf</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Anonymous Memoizing Lazy Lists]]></title>
    <link href="http://rebcabin.github.com/blog/2012/12/08/anonymous-memoizing-lazy-lists/"/>
    <updated>2012-12-08T20:41:00-08:00</updated>
    <id>http://rebcabin.github.com/blog/2012/12/08/anonymous-memoizing-lazy-lists</id>
    <content type="html"><![CDATA[<p>A vastly prettier version of this blog can be found 
in the CDF file here: <a href="https://dl.dropbox.com/u/1997638/LazyLambda003.cdf">https://dl.dropbox.com/u/1997638/LazyLambda003.cdf</a>. Wolfram’s free CDF reader is found at <a href="http://www.wolfram.com/cdf-player/">http://www.wolfram.com/cdf-player/</a>.</p>

<p>One reason to care about anonymized computations is that naming things costs memory, and it’s the kind of memory that lasts from one computation to another – session memory. Naming things means writing definitions and storing them in tables for access in later computations. Building up big memoization tables as definitions can cost a LOT of memory. We can save this cost if we can avoid naming things, storing information in function parameters that only last the lifetime of a single computation.</p>

<h2 id="non-anonymous-lazy-lists">NON-ANONYMOUS LAZY LISTS</h2>

<p>Lazy lists are a handy way of expressing infinite data streams. A typical lazy list might look like the following:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">In[1]:= integersFrom[n_] := {n, integersFrom[n + 1] &amp;}</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>Calling <code>integersFrom</code> with some numerical argument produces a list in curly braces, the first element of which is that numerical argument and the second element of which is a delayed list in the form of a nullary function – a function of no parameters. That’s what the <code>&amp;</code> means: “the expression to my left is a function.” We’re doing Lisp-style lists, which are pairs of values and lists.</p>

<p>The list in the second slot of the lazy list won’t be automatically evaluated – we must manually invoke the function that produces it when we want the results. That is the essence of lazy computation. Lazy languages like Haskell can decide when you need the results and just sidestep the explicit wrapping in a nullary function and the manual invocation. With eager or strict languages like Mathematica, we must do the invocations manually. But that’s good, because we can see more clearly what’s going on. </p>

<p>In our lazy lists, the second item will always be a nullary function.</p>

<p>Start peeling integers off such a structure one at a time. <code>integersFrom[0]</code> will be a lazy list of integers starting from 0, and 
<code>[[1]]</code> will pick the first element from the resulting list:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class=""><span class="line">In[2]:= integersFrom[0][[1]]
</span><span class="line">Out[2]= 0</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>If we pick the second element from <code>integersFrom[0]</code>, that will be a nullary function that produces the next lazy list. Manually invoke the function by appending <code>[]</code> – invocation brackets containing no arguments – and then pick off the first element of the result to get the next integer.</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class=""><span class="line">In[3]:= integersFrom[0][[2]][][[1]]
</span><span class="line">Out[3]= 1</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>And so on:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class=""><span class="line">In[4]:= integersFrom[0][[2]][][[2]][][[1]]
</span><span class="line">Out[4]= 2</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>A pattern emerges that we can capture in some operators. <code>Value</code> just picks the first element of a lazy list, and <code>next</code> picks the second element – the nullary function – and invokes it on no arguments:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
</pre></td><td class="code"><pre><code class=""><span class="line">In[5]:= value[stream_] := stream[[1]];
</span><span class="line">next[stream_] := stream[[2]][];
</span><span class="line">
</span><span class="line">In[7]:= value@integersFrom[0]
</span><span class="line">Out[7]= 0
</span><span class="line">
</span><span class="line">In[8]:= value@next@integersFrom[0]
</span><span class="line">Out[8]= 1
</span><span class="line">
</span><span class="line">In[9]:= value@next@next@integersFrom[0]
</span><span class="line">Out[9]= 2</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>Improve the <code>value</code> operator so we can ask for the <code>n</code> th value, recursively:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
</pre></td><td class="code"><pre><code class=""><span class="line">In[10]:= ClearAll[value];
</span><span class="line">value[stream_, n_: 1] :=
</span><span class="line"> If[n &lt;= 1,
</span><span class="line">  stream[[1]],
</span><span class="line">  value[next[stream], n - 1]]
</span><span class="line">
</span><span class="line">In[12]:= value[integersFrom[1], 26]
</span><span class="line">Out[12]= 26</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>Let’s see a few values by mapping over a list of inputs:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class=""><span class="line">In[13]:= value[integersFrom[1], #] &amp; /@ {1, 2, 3, 4, 5, 10, 15, 20}
</span><span class="line">Out[13]= {1, 2, 3, 4, 5, 10, 15, 20}</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>We don’t need <code>next</code> any more – only <code>value</code> used it. Inline it in the body of <code>value</code>:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
</pre></td><td class="code"><pre><code class=""><span class="line">In[14]:= ClearAll[next, value];
</span><span class="line">value[stream_, n_: 1] :=
</span><span class="line">  If[n &lt;= 1,
</span><span class="line">   stream[[1]],
</span><span class="line">   value[stream[[2]][], n - 1]];</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>As an aside, an efficient implementation of <code>value</code> requires either the tail-recursion optimization in the interpreter or a re-expression in iterative form, which can be done semi-automatically.</p>

<p>Write another lazy list as follows:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
</pre></td><td class="code"><pre><code class=""><span class="line">In[16]:= ClearAll[fibonaccis];
</span><span class="line">fibonaccis[n_] :=
</span><span class="line"> {If[n &lt;= 1,
</span><span class="line">   1,
</span><span class="line">   value[fibonaccis[n - 1]] + value[fibonaccis[n - 2]]],
</span><span class="line">  fibonaccis[n + 1] &amp;
</span><span class="line">  }
</span><span class="line">
</span><span class="line">In[18]:= Timing[value[fibonaccis[1], 15]]
</span><span class="line">Out[18]= {0.024130, 987}</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>Of course, this is exponentially inefficient, as are all non-memoizing recursive fibonaccis. Fib of 15 is already painful, and fib of 150 is unthinkable. This can be mitigated as follows:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
</pre></td><td class="code"><pre><code class=""><span class="line">In[19]:= ClearAll[fibonaccis];
</span><span class="line">fibonaccis[n_] :=
</span><span class="line"> fibonaccis[n] =
</span><span class="line">  {If[n &lt;= 1,
</span><span class="line">    1,
</span><span class="line">    value[fibonaccis[n - 1]] + value[fibonaccis[n - 2]]],
</span><span class="line">   fibonaccis[n + 1] &amp;
</span><span class="line">   }
</span><span class="line">
</span><span class="line">In[21]:= fibonaccis[#] &amp; /@ {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 15, 20}
</span><span class="line">Out[21]= {{1, fibonaccis[1 + 1] &amp;}, {2, fibonaccis[2 + 1] &amp;}, {3, 
</span><span class="line">  fibonaccis[3 + 1] &amp;}, {5, fibonaccis[4 + 1] &amp;}, {8, 
</span><span class="line">  fibonaccis[5 + 1] &amp;}, {13, fibonaccis[6 + 1] &amp;}, {21, 
</span><span class="line">  fibonaccis[7 + 1] &amp;}, {34, fibonaccis[8 + 1] &amp;}, {55, 
</span><span class="line">  fibonaccis[9 + 1] &amp;}, {89, fibonaccis[10 + 1] &amp;}, {987, 
</span><span class="line">  fibonaccis[15 + 1] &amp;}, {10946, fibonaccis[20 + 1] &amp;}}
</span><span class="line">
</span><span class="line">In[22]:= Timing[value[fibonaccis[1], 150]]
</span><span class="line">Out[22]= {0.001997, 16130531424904581415797907386349}</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>This is a well-known Mathematica idiom for building a memo table by side effect. The memo table consists of explicit, specific point-values for <code>fibonaccis</code>, which the general <code>fibonaccis</code> – the one depending on a single parameter <code>n_</code> – creates on-the-fly. Subsequent references to <code>fibonaccis</code>` at known inputs will do a quick lookup on the specific values and avoid the exponential recomputation. </p>

<p>This is non-anonymous programming on steroids – everything is built up inside the named object <code>fibonaccis</code>, but it gives us great speed at the expense of memory. But this is global memory in Mathematica’s global brain. When we’re done with the calculation, we have modified the session state of Mathematica and not left things the way we found them. In some scenarios, this would not be allowed. We must find some other way to evaluate recursive formulas without requiring session state – using only ephemeral memory such as stack frames that go away when our result is achieved.</p>

<p>Let’s get rid of the named functions and then even get rid of the named memo table so we can have decent performance on our recursive evaluations.</p>

<h2 id="anonymize">ANONYMIZE</h2>

<p>The mother of all anonymizers is the Y combinator:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class=""><span class="line">In[23]:= Y = (subjectCode \[Function] (g \[Function] g@g)
</span><span class="line">     [precursor \[Function] subjectCode
</span><span class="line">       [n \[Function] precursor[precursor][n]]]);</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>Without going into how it works, Y is a function that takes another function as an argument. That other function takes an argument <code>k</code> and produces a function of <code>n</code>. The function of <code>n</code> can call <code>k</code> as if <code>k</code> were a recursive definition of the function of <code>n</code>. The function of <code>n</code> can be applied to workhorse arguments, that is, to arguments of the subject code.</p>

<p>In practice, Y is easy to use: just apply it to a function of <code>k</code> that produces a function of <code>n</code> that internally calls <code>k</code>, then apply the result to the desired <code>n</code>.  </p>

<p>Here is the lazy list of integers, this time starting at 1, without using the name of the lazy list inside the definition of the lazy list: s1 does not refer to s1:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
</pre></td><td class="code"><pre><code class=""><span class="line">In[24]:= ClearAll[s1];
</span><span class="line">s1 = Y[k \[Function] n \[Function]
</span><span class="line">      {n, k[n + 1] &amp;}
</span><span class="line">    ][1];
</span><span class="line">
</span><span class="line">In[26]:= value[s1]
</span><span class="line">Out[26]= 1</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>We feed to Y a function of <code>k</code>. That function of <code>k</code> produces a function of <code>n</code>. That function of <code>n</code> produces a list in curly braces. The first element of that list is the value <code>n</code>, and the second element of that list is a delayed call of <code>k</code> on the next value, <code>n+1</code>. <code>s1</code> is thus a lazy list of all the integers, just defined without reference to any names but parameters. No global storage needed, no session state. </p>

<p>Let’s map calls of <code>value[s1,#]&amp;</code> over a sequence of inputs to consicely show it off multiple times:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class=""><span class="line">In[27]:= value[s1, #] &amp; /@ {1, 2, 3, 4, 26}
</span><span class="line">Out[27]= {1, 2, 3, 4, 26}</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>Now, on to an anonymized lazy list of fibonaccis:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
</pre></td><td class="code"><pre><code class=""><span class="line">In[28]:= ClearAll[s2];
</span><span class="line">s2 = Y[k \[Function] n \[Function]
</span><span class="line">      {If[n &lt;= 1,
</span><span class="line">        1,
</span><span class="line">        value[k[n - 1]] + value[k[n - 2]]],
</span><span class="line">       k[n + 1] &amp;}
</span><span class="line">    ][1];</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>This one is still slow:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class=""><span class="line">In[30]:= Timing[value[s2, #] &amp; /@ {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 15, 20}]
</span><span class="line">Out[30]= {0.883336, {1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 987, 10946}}</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>It takes about a second to produce <code>fib[20]</code>, and higher values become intolerable. We would never get to an absurd input like 150.</p>

<h2 id="memoize">MEMOIZE</h2>

<p>How can we speed it up without defining point values in some named object? By defining point values in an un-named object, of course! Un-named objects are best modeled in Mathematica as lists of rules, one for each point-like input. We’ll need to pass that around in the argument list of <code>k</code>, and the easiest way to do that is to make <code>n</code>, the argument of <code>k</code>, a regular Mathematica list to contain both a value and an anonymous dictionary. </p>

<p>We’ll get to this form in a few steps. First, just change <code>n</code> so that it’s a list rather than an integer. This change spreads a lot of indexing around the body of <code>k</code>, so we want to make sure we get that right before proceeding:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
</pre></td><td class="code"><pre><code class=""><span class="line">In[31]:= ClearAll[s3];
</span><span class="line">s3 = Y[k \[Function] n \[Function]
</span><span class="line">      {If[n[[1]] &lt;= 1,
</span><span class="line">        {1},
</span><span class="line">        {value[k[{n[[1]] - 1}]][[1]] +
</span><span class="line">          value[k[{n[[1]] - 2}]][[1]]}
</span><span class="line">        ],
</span><span class="line">       k[{n[[1]] + 1}] &amp;}
</span><span class="line">    ][{1}];
</span><span class="line">
</span><span class="line">In[33]:= Timing[value[s3, #] &amp; /@ {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 15, 20}]
</span><span class="line">Out[33]= {1.145393, {{1}, {2}, {3}, {5}, {8}, {13}, {21}, {34}, {55}, {89}, {987}, \
</span><span class="line">{10946}}}</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>Now add a second element – an empty list – to <code>n</code>, but ignore it in the code, just to make sure we get all the shaping correct. We must modify six places where arguments to k are constructed:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
</pre></td><td class="code"><pre><code class=""><span class="line">In[34]:= ClearAll[s4];
</span><span class="line">s4 = Y[k \[Function] n \[Function]
</span><span class="line">      {If[n[[1]] &lt;= 1,
</span><span class="line">        {1, {}},(* 
</span><span class="line">        modification 1 *)
</span><span class="line">        {value[k[{n[[1]] - 1, {}}]][[1]] + (* 
</span><span class="line">          modification 2 *)
</span><span class="line">          value[k[{n[[1]] - 2, {}}]][[1]],
</span><span class="line">         (* modification 3 *)
</span><span class="line">         {}} (* modification 4 *)
</span><span class="line">        ],
</span><span class="line">       k[{n[[1]] + 1, {}}] &amp;} (* 
</span><span class="line">    modification 5 *)
</span><span class="line">    ][{1, {}}]; (* modification 6 *)
</span><span class="line">
</span><span class="line">In[36]:= Timing[value[s4, #] &amp; /@ {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 15, 20}]
</span><span class="line">Out[36]= {1.214176, {{1, {}}, {2, {}}, {3, {}}, {5, {}}, {8, {}}, {13, {}}, {21, {}}, \
</span><span class="line">{34, {}}, {55, {}}, {89, {}}, {987, {}}, {10946, {}}}}</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>Now replace the internal constant empty lists with references to the second slot of <code>n</code>, where we will eventually store the dictionary:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
</pre></td><td class="code"><pre><code class=""><span class="line">In[37]:= ClearAll[s5];
</span><span class="line">s5 = Y[k \[Function] n \[Function]
</span><span class="line">      {If[n[[1]] &lt;= 1,
</span><span class="line">        {1, n[[2]]},
</span><span class="line">        {value[k[{n[[1]] - 1, n[[2]]}]][[1]] +
</span><span class="line">          value[k[{n[[1]] - 2, n[[2]]}]][[1]],
</span><span class="line">         n[[2]]}
</span><span class="line">        ],
</span><span class="line">       k[{n[[1]] + 1, n[[2]]}] &amp;}
</span><span class="line">    ][{1, {}}];
</span><span class="line">
</span><span class="line">In[39]:= Timing[value[s5, #] &amp; /@ {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 15, 20}]
</span><span class="line">Out[39]= {1.308497, {{1, {}}, {2, {}}, {3, {}}, {5, {}}, {8, {}}, {13, {}}, {21, {}}, \
</span><span class="line">{34, {}}, {55, {}}, {89, {}}, {987, {}}, {10946, {}}}}</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>We’re now ready to promote that second part of <code>n</code> into a dictionary – same as anonymous object, same as list of rules – for fast lookups. Let’s take the convention that if a key is not present in the dictionary, we produce <code>Null</code>, and make a few helper functions:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
</pre></td><td class="code"><pre><code class=""><span class="line">In[40]:= ClearAll[lookup, add];
</span><span class="line">lookup[dict_, key_] := key /. dict;
</span><span class="line">add[dict_, key_, value_] :=
</span><span class="line">  With[{trial = lookup[dict, key]},
</span><span class="line">   If[trial =!= Null,
</span><span class="line">    dict,
</span><span class="line">    If[Head[dict] === Dispatch,
</span><span class="line">     Dispatch[Prepend[dict[[1]], key -&gt; value]],
</span><span class="line">     Dispatch[Prepend[dict, key -&gt; value]]]]];</span></code></pre></td></tr></table></div></figure></notextile></div>

<p><code>Add</code> converts the dictionary into a hash table by applying the Mathematica built-in <code>Dispatch</code> to it. This is similar to what relational databases do when computing joins – creates a temporary hash table and uses it. Before adding a new rule to the table, add must check whether the input table is already a hash table since the original list of rules is stored in slot 1 of a hash table. <code>Add</code> can only add a rule to a list of rules, not to a hash table, but <code>add</code> can regenerate a new hash table in linear time. This is a potential hidden quadratic in this code since the hash table will be created over and over again. It does not seem to be a serious problem, here, likely overwhelmed by other overheads.</p>

<p>Now add the code to store computed values in the anonymous object. We must modify the initial input from <code>{1, {}}</code> to <code>{1, {_-&gt;Null}}</code> so that the starting dictionary has the default rule.</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
</pre></td><td class="code"><pre><code class=""><span class="line">In[43]:= ClearAll[s6];
</span><span class="line">s6 = Y[k \[Function] n \[Function]
</span><span class="line">      Module[{valToStore, dict = n[[2]]},
</span><span class="line">       {If[n[[1]] &lt;= 1,
</span><span class="line">         {1, dict},
</span><span class="line">         valToStore =
</span><span class="line">          value[k[{n[[1]] - 1, dict}]][[1]] +
</span><span class="line">           value[k[{n[[1]] - 2, dict}]][[1]];
</span><span class="line">         dict = add[dict, n[[1]], valToStore];
</span><span class="line">         {valToStore, dict}
</span><span class="line">         ],
</span><span class="line">        k[{n[[1]] + 1, dict}] &amp;}]
</span><span class="line">    ][{1, {_ -&gt; Null}}];
</span><span class="line">
</span><span class="line">In[45]:= Timing[value[s6, #] &amp; /@ {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 15, 20}]
</span><span class="line">
</span><span class="line">Out[45]= {6.912630,
</span><span class="line">{{1,{_-&gt;Null}},
</span><span class="line">{2,{2-&gt;2,_-&gt;Null}},
</span><span class="line">{3,{3-&gt;3,2-&gt;2,_-&gt;Null}},
</span><span class="line">{5,{4-&gt;5,3-&gt;3,2-&gt;2,_-&gt;Null}},
</span><span class="line">{8,Dispatch[{5-&gt;8,4-&gt;5,3-&gt;3,2-&gt;2,_-&gt;Null},-DispatchTables-]},
</span><span class="line">{13,Dispatch[{6-&gt;13,5-&gt;8,4-&gt;5,3-&gt;3,2-&gt;2,_-&gt;Null},-DispatchTables-]},
</span><span class="line">{21,Dispatch[{7-&gt;21,6-&gt;13,5-&gt;8,4-&gt;5,3-&gt;3,2-&gt;2,_-&gt;Null},-DispatchTables-]},
</span><span class="line">{34,Dispatch[{8-&gt;34,7-&gt;21,6-&gt;13,5-&gt;8,4-&gt;5,3-&gt;3,2-&gt;2,_-&gt;Null},-DispatchTables-]},
</span><span class="line">{55,Dispatch[{9-&gt;55,8-&gt;34,7-&gt;21,6-&gt;13,5-&gt;8,4-&gt;5,3-&gt;3,2-&gt;2,_-&gt;Null},-DispatchTables-]},
</span><span class="line">{89,Dispatch[{10-&gt;89,9-&gt;55,8-&gt;34,7-&gt;21,6-&gt;13,5-&gt;8,4-&gt;5,3-&gt;3,2-&gt;2,_-&gt;Null},-DispatchTables-]},
</span><span class="line">{987,Dispatch[{15-&gt;987,14-&gt;610,13-&gt;377,12-&gt;233,11-&gt;144,10-&gt;89,9-&gt;55,8-&gt;34,7-&gt;21,6-&gt;13,5-&gt;8,4-&gt;5,3-&gt;3,2-&gt;2,_-&gt;Null},-DispatchTables-]},
</span><span class="line">{10946,Dispatch[{20-&gt;10946,19-&gt;6765,18-&gt;4181,17-&gt;2584,16-&gt;1597,15-&gt;987,14-&gt;610,13-&gt;377,12-&gt;233,11-&gt;144,10-&gt;89,9-&gt;55,8-&gt;34,7-&gt;21,6-&gt;13,5-&gt;8,4-&gt;5,3-&gt;3,2-&gt;2,_-&gt;Null},-DispatchTables-]}}}
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>Now add code to do lookups</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
</pre></td><td class="code"><pre><code class=""><span class="line">In[46]:= ClearAll[s7];
</span><span class="line">s7 = Y[k \[Function] n \[Function]
</span><span class="line">      Module[{valToStore, dict = n[[2]]},
</span><span class="line">       {If[n[[1]] &lt;= 1,
</span><span class="line">         {1, dict},
</span><span class="line">         valToStore =
</span><span class="line">          With[{
</span><span class="line">            v1 = lookup[dict, n[[1]] - 1],
</span><span class="line">            v2 = lookup[dict, n[[2]] - 2]},
</span><span class="line">           If[v1 =!= Null, v1,
</span><span class="line">             value[k[{n[[1]] - 1, dict}]][[1]]] +
</span><span class="line">            If[v2 =!= Null, v2,
</span><span class="line">             value[k[{n[[1]] - 2, dict}]][[1]]]];
</span><span class="line">         dict = add[dict, n[[1]], valToStore];
</span><span class="line">         {valToStore, dict}
</span><span class="line">         ],
</span><span class="line">        k[{n[[1]] + 1, dict}] &amp;}]
</span><span class="line">    ][{1, {_ -&gt; Null}}];</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>Now our regular example is much faster and an otherwise inconceivable computation such as <code>fib[150]</code> can be done in a reasonable time. </p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
</pre></td><td class="code"><pre><code class=""><span class="line">In[48]:= Timing[
</span><span class="line"> value[s7, #][[1]] &amp; /@ {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 15, 20}]
</span><span class="line">Out[48]= {0.068064, {1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 987, 10946}}
</span><span class="line">
</span><span class="line">In[49]:= Block[{$RecursionLimit = 2000}, Timing[value[s7, 150][[1]]]]
</span><span class="line">Out[49]= {1.308640, 16130531424904581415797907386349}</span></code></pre></td></tr></table></div></figure></notextile></div>

<h2 id="conclusion">CONCLUSION</h2>

<p>Many improvements can be made to this, such as getting rid of the mutable variables in the <code>Module</code> by a monadic bind and refactoring the code for readability. However, we have shown a general technique for creating lazy memoizing lists without introducing names or session state into an evaluator or interpreter.</p>
]]></content>
  </entry>
  
</feed>
